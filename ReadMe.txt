
Oops, 这份代码编译失败了！

为什么会编译失败？
    因为代码并没有完工，里面仍然有尚未实现的函数，甚至不完善的架构。
    （因为遇到了小黄鸭都无法攻克的bug)

为什么没有完工？
    因为作者的拖延症以及其他更多更紧迫的事务，最后留给这项工程的时间
    并不足以完成它。模糊不清的任务指向和晦涩难懂的fix协议＆boost库的
    使用，也是难以完成的原因。（甚至还有“多线程”的编程方法）

我该怎么办，给他打零分吗？
    当然不！虽然他的工程并不能运行，但是他的编程思想已经包含在他残存
    的代码中了。所有的头文件都包含详细完整的注释，所有代码都详细遵循
    了良好的程序设计风格。应该阅读完他的代码，再考虑应给的分数。

编译都编译不过，不打零分有天理吗？有吗？
    有！当然有！号称最为公平公正的高考规则中，题目即使没有完成，也应
    该按步骤给分。当解题思路明显，过程清晰漂亮，仅仅是答案不正确，应
    给的分数应该很高才对。所以不打零分，也是公平公正的体现。

竟然还有脸皮这么厚的人的存在？
    有……吧～

    下面用中文给出思路的详细描述，源码文件中的英文注释如果有愚蠢
    的错误，请不要放声大笑。

/* 思路描述 */

    .h文件和.cpp文件分为三种，*_s.*服务器专用、*_c.*客户端专用、
    *_sh.*两者共用。（管理员客户端本来设想是在普通客户端上通过不同的
    方式登录来实现的，因此没有额外内容）
   
    服务器
	初始化boost
	读取orderbook.txt的内容，并将其中每一行转化成一个Order类并存
	入一个set容器。（可读的"order"转化成Order类是通过Order类的构
	造函数实现的，Order类其实是tag的集合，并定义了不变式确保其合
	法性）。
	接受一个fix message并使用fix scanner把它转换成一些tag的集合
	并判断用户的要求，如果是创建新order就新建Order类，cancel 
	order 就调用Order类的cancel方法。
	为当前Order寻找匹配，如果匹配成功立即处理，否则存入orderbook
	为orderbook中每一个买方order寻找匹配。
	将当前set容器的状态刷入orderbook.txt。
	
    客户端
	初始化boost
	输出提示语。
	获取用户的一个输入，并把它翻译成基于fix的命令，发送给服务器。
	从服务器接受ack，将其翻译成便于用户理解的语句并打印出来。
	
    管理员客户端 
	在客户端预留管理员登录方式。
	其他与客户端基本相同。
